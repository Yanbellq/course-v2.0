{"version":3,"names":[],"mappings":"","sources":["form-validation.js"],"sourcesContent":["// ============ FORM VALIDATION UTILITIES ============\n\n/**\n * Показує помилку валідації під полем\n */\nexport function showFieldError(field, message) {\n    // Видаляємо попередню помилку, якщо є\n    clearFieldError(field);\n    \n    // Створюємо елемент помилки\n    const errorElement = document.createElement('p');\n    errorElement.className = 'field-error';\n    errorElement.textContent = message;\n    errorElement.style.cssText = `\n        color: #dc3545;\n        font-size: 0.875rem;\n        margin-top: 0.25rem;\n        margin-bottom: 0;\n    `;\n    \n    // Додаємо стиль до поля\n    field.style.borderColor = '#dc3545';\n    \n    // Вставляємо помилку після поля\n    field.parentElement.appendChild(errorElement);\n}\n\n/**\n * Видаляє помилку валідації з поля\n */\nexport function clearFieldError(field) {\n    const errorElement = field.parentElement.querySelector('.field-error');\n    if (errorElement) {\n        errorElement.remove();\n    }\n    field.style.borderColor = '';\n}\n\n/**\n * Перевірка email на унікальність (async)\n */\nexport async function checkEmailUnique(email, currentEmail = null, checkUrl = null) {\n    if (!email || email === currentEmail) {\n        return { unique: true };\n    }\n    \n    // Якщо URL не передано, використовуємо стандартний\n    if (!checkUrl) {\n        // Можна додати API endpoint для перевірки унікальності\n        return { unique: true };\n    }\n    \n    try {\n        const response = await fetch(checkUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRFToken': getCsrfToken(),\n            },\n            body: JSON.stringify({ email }),\n        });\n        \n        const data = await response.json();\n        return { unique: data.unique !== false };\n    } catch (error) {\n        console.error('Error checking email uniqueness:', error);\n        return { unique: true }; // У разі помилки дозволяємо продовжити\n    }\n}\n\n/**\n * Перевірка username на унікальність (async)\n */\nexport async function checkUsernameUnique(username, currentUsername = null, checkUrl = null) {\n    if (!username || username === currentUsername) {\n        return { unique: true };\n    }\n    \n    if (!checkUrl) {\n        return { unique: true };\n    }\n    \n    try {\n        const response = await fetch(checkUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRFToken': getCsrfToken(),\n            },\n            body: JSON.stringify({ username }),\n        });\n        \n        const data = await response.json();\n        return { unique: data.unique !== false };\n    } catch (error) {\n        console.error('Error checking username uniqueness:', error);\n        return { unique: true };\n    }\n}\n\n/**\n * Отримує CSRF token з форми\n */\nfunction getCsrfToken() {\n    const csrfInput = document.querySelector('input[name=\"csrfmiddlewaretoken\"]');\n    return csrfInput ? csrfInput.value : '';\n}\n\n/**\n * Валідація email формату\n */\nexport function validateEmail(email) {\n    const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n    return emailPattern.test(email);\n}\n\n/**\n * Валідація пароля\n */\nexport function validatePassword(password, minLength = 6) {\n    if (!password) {\n        return { valid: false, message: 'Password is required' };\n    }\n    if (password.length < minLength) {\n        return { valid: false, message: `Password must be at least ${minLength} characters` };\n    }\n    return { valid: true };\n}\n\n/**\n * Перевірка співпадіння паролів\n */\nexport function validatePasswordMatch(password, passwordConfirm) {\n    if (!passwordConfirm) {\n        return { valid: false, message: 'Please confirm your password' };\n    }\n    if (password !== passwordConfirm) {\n        return { valid: false, message: 'Passwords do not match' };\n    }\n    return { valid: true };\n}\n\n/**\n * Валідація username\n */\nexport function validateUsername(username, minLength = 3) {\n    if (!username) {\n        return { valid: false, message: 'Username is required' };\n    }\n    if (username.length < minLength) {\n        return { valid: false, message: `Username must be at least ${minLength} characters` };\n    }\n    // Перевірка на дозволені символи\n    const usernamePattern = /^[a-zA-Z0-9_]+$/;\n    if (!usernamePattern.test(username)) {\n        return { valid: false, message: 'Username can only contain letters, numbers, and underscores' };\n    }\n    return { valid: true };\n}\n\n/**\n * Debounce функція для затримки перевірок\n */\nexport function debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n        const later = () => {\n            clearTimeout(timeout);\n            func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n\n/**\n * Форматує номер телефону в формат +380 (00) 000 00-00\n */\nexport function formatPhoneNumber(value) {\n    // Видаляємо всі нецифрові символи\n    const numbers = value.replace(/\\D/g, '');\n    \n    // Якщо номер починається з 380, залишаємо як є\n    // Якщо починається з 0, замінюємо на 380\n    // Якщо починається з інших цифр, додаємо 380\n    let formatted = numbers;\n    \n    if (numbers.length > 0) {\n        if (numbers.startsWith('380')) {\n            formatted = numbers;\n        } else if (numbers.startsWith('0')) {\n            formatted = '380' + numbers.substring(1);\n        } else if (numbers.length <= 9) {\n            formatted = '380' + numbers;\n        }\n        \n        // Обмежуємо до 12 цифр (380 + 9 цифр)\n        formatted = formatted.substring(0, 12);\n        \n        // Форматуємо: +380 (XX) XXX XX-XX\n        if (formatted.length >= 3) {\n            let result = '+' + formatted.substring(0, 3);\n            if (formatted.length > 3) {\n                result += ' (' + formatted.substring(3, 5);\n                if (formatted.length > 5) {\n                    result += ') ' + formatted.substring(5, 8);\n                    if (formatted.length > 8) {\n                        result += ' ' + formatted.substring(8, 10);\n                        if (formatted.length > 10) {\n                            result += '-' + formatted.substring(10, 12);\n                        }\n                    }\n                } else {\n                    result += ')';\n                }\n            }\n            return result;\n        }\n    }\n    \n    return value;\n}\n\n/**\n * Валідація номера телефону\n */\nexport function validatePhone(phone) {\n    if (!phone) {\n        return { valid: false, message: 'Phone number is required' };\n    }\n    \n    // Видаляємо всі нецифрові символи для перевірки\n    const numbers = phone.replace(/\\D/g, '');\n    \n    // Перевіряємо формат +380XXXXXXXXX (12 цифр)\n    if (!numbers.startsWith('380') || numbers.length !== 12) {\n        return { valid: false, message: 'Phone number must be in format +380 (XX) XXX XX-XX' };\n    }\n    \n    return { valid: true };\n}\n\n"],"file":"form-validation.js"}