{"version":3,"names":[],"mappings":"","sources":["form-validation.js"],"sourcesContent":["// ============ FORM VALIDATION UTILITIES ============\r\n\r\n/**\r\n * Показує помилку валідації під полем\r\n */\r\nexport function showFieldError(field, message) {\r\n    // Видаляємо попередню помилку, якщо є\r\n    clearFieldError(field);\r\n    \r\n    // Створюємо елемент помилки\r\n    const errorElement = document.createElement('p');\r\n    errorElement.className = 'field-error';\r\n    errorElement.textContent = message;\r\n    errorElement.style.cssText = `\r\n        color: #dc3545;\r\n        font-size: 0.875rem;\r\n        margin-top: 0.25rem;\r\n        margin-bottom: 0;\r\n    `;\r\n    \r\n    // Додаємо стиль до поля\r\n    field.style.borderColor = '#dc3545';\r\n    \r\n    // Вставляємо помилку після поля\r\n    field.parentElement.appendChild(errorElement);\r\n}\r\n\r\n/**\r\n * Видаляє помилку валідації з поля\r\n */\r\nexport function clearFieldError(field) {\r\n    const errorElement = field.parentElement.querySelector('.field-error');\r\n    if (errorElement) {\r\n        errorElement.remove();\r\n    }\r\n    field.style.borderColor = '';\r\n}\r\n\r\n/**\r\n * Перевірка email на унікальність (async)\r\n */\r\nexport async function checkEmailUnique(email, currentEmail = null, checkUrl = null) {\r\n    if (!email || email === currentEmail) {\r\n        return { unique: true };\r\n    }\r\n    \r\n    // Якщо URL не передано, використовуємо стандартний\r\n    if (!checkUrl) {\r\n        // Можна додати API endpoint для перевірки унікальності\r\n        return { unique: true };\r\n    }\r\n    \r\n    try {\r\n        const response = await fetch(checkUrl, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'X-CSRFToken': getCsrfToken(),\r\n            },\r\n            body: JSON.stringify({ email }),\r\n        });\r\n        \r\n        const data = await response.json();\r\n        return { unique: data.unique !== false };\r\n    } catch (error) {\r\n        console.error('Error checking email uniqueness:', error);\r\n        return { unique: true }; // У разі помилки дозволяємо продовжити\r\n    }\r\n}\r\n\r\n/**\r\n * Перевірка username на унікальність (async)\r\n */\r\nexport async function checkUsernameUnique(username, currentUsername = null, checkUrl = null) {\r\n    if (!username || username === currentUsername) {\r\n        return { unique: true };\r\n    }\r\n    \r\n    if (!checkUrl) {\r\n        return { unique: true };\r\n    }\r\n    \r\n    try {\r\n        const response = await fetch(checkUrl, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'X-CSRFToken': getCsrfToken(),\r\n            },\r\n            body: JSON.stringify({ username }),\r\n        });\r\n        \r\n        const data = await response.json();\r\n        return { unique: data.unique !== false };\r\n    } catch (error) {\r\n        console.error('Error checking username uniqueness:', error);\r\n        return { unique: true };\r\n    }\r\n}\r\n\r\n/**\r\n * Отримує CSRF token з форми\r\n */\r\nfunction getCsrfToken() {\r\n    const csrfInput = document.querySelector('input[name=\"csrfmiddlewaretoken\"]');\r\n    return csrfInput ? csrfInput.value : '';\r\n}\r\n\r\n/**\r\n * Валідація email формату\r\n */\r\nexport function validateEmail(email) {\r\n    const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\r\n    return emailPattern.test(email);\r\n}\r\n\r\n/**\r\n * Валідація пароля\r\n */\r\nexport function validatePassword(password, minLength = 6) {\r\n    if (!password) {\r\n        return { valid: false, message: 'Password is required' };\r\n    }\r\n    if (password.length < minLength) {\r\n        return { valid: false, message: `Password must be at least ${minLength} characters` };\r\n    }\r\n    return { valid: true };\r\n}\r\n\r\n/**\r\n * Перевірка співпадіння паролів\r\n */\r\nexport function validatePasswordMatch(password, passwordConfirm) {\r\n    if (!passwordConfirm) {\r\n        return { valid: false, message: 'Please confirm your password' };\r\n    }\r\n    if (password !== passwordConfirm) {\r\n        return { valid: false, message: 'Passwords do not match' };\r\n    }\r\n    return { valid: true };\r\n}\r\n\r\n/**\r\n * Валідація username\r\n */\r\nexport function validateUsername(username, minLength = 3) {\r\n    if (!username) {\r\n        return { valid: false, message: 'Username is required' };\r\n    }\r\n    if (username.length < minLength) {\r\n        return { valid: false, message: `Username must be at least ${minLength} characters` };\r\n    }\r\n    // Перевірка на дозволені символи\r\n    const usernamePattern = /^[a-zA-Z0-9_]+$/;\r\n    if (!usernamePattern.test(username)) {\r\n        return { valid: false, message: 'Username can only contain letters, numbers, and underscores' };\r\n    }\r\n    return { valid: true };\r\n}\r\n\r\n/**\r\n * Debounce функція для затримки перевірок\r\n */\r\nexport function debounce(func, wait) {\r\n    let timeout;\r\n    return function executedFunction(...args) {\r\n        const later = () => {\r\n            clearTimeout(timeout);\r\n            func(...args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}\r\n\r\n/**\r\n * Форматує номер телефону в формат +380 (00) 000 00-00\r\n */\r\nexport function formatPhoneNumber(value) {\r\n    // Видаляємо всі нецифрові символи\r\n    const numbers = value.replace(/\\D/g, '');\r\n    \r\n    // Якщо номер починається з 380, залишаємо як є\r\n    // Якщо починається з 0, замінюємо на 380\r\n    // Якщо починається з інших цифр, додаємо 380\r\n    let formatted = numbers;\r\n    \r\n    if (numbers.length > 0) {\r\n        if (numbers.startsWith('380')) {\r\n            formatted = numbers;\r\n        } else if (numbers.startsWith('0')) {\r\n            formatted = '380' + numbers.substring(1);\r\n        } else if (numbers.length <= 9) {\r\n            formatted = '380' + numbers;\r\n        }\r\n        \r\n        // Обмежуємо до 12 цифр (380 + 9 цифр)\r\n        formatted = formatted.substring(0, 12);\r\n        \r\n        // Форматуємо: +380 (XX) XXX XX-XX\r\n        if (formatted.length >= 3) {\r\n            let result = '+' + formatted.substring(0, 3);\r\n            if (formatted.length > 3) {\r\n                result += ' (' + formatted.substring(3, 5);\r\n                if (formatted.length > 5) {\r\n                    result += ') ' + formatted.substring(5, 8);\r\n                    if (formatted.length > 8) {\r\n                        result += ' ' + formatted.substring(8, 10);\r\n                        if (formatted.length > 10) {\r\n                            result += '-' + formatted.substring(10, 12);\r\n                        }\r\n                    }\r\n                } else {\r\n                    result += ')';\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    \r\n    return value;\r\n}\r\n\r\n/**\r\n * Валідація номера телефону\r\n */\r\nexport function validatePhone(phone) {\r\n    if (!phone) {\r\n        return { valid: false, message: 'Phone number is required' };\r\n    }\r\n    \r\n    // Видаляємо всі нецифрові символи для перевірки\r\n    const numbers = phone.replace(/\\D/g, '');\r\n    \r\n    // Перевіряємо формат +380XXXXXXXXX (12 цифр)\r\n    if (!numbers.startsWith('380') || numbers.length !== 12) {\r\n        return { valid: false, message: 'Phone number must be in format +380 (XX) XXX XX-XX' };\r\n    }\r\n    \r\n    return { valid: true };\r\n}\r\n\r\n"],"file":"form-validation.js"}